# -*- coding: utf-8 -*-
"""Leader-Follower Based Formation .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10OrZAZBxNRUDEVazYxa0LlEuMaZHwn-K
"""

import numpy as np
import math
import matplotlib.pyplot as plt

b = 0.50
g = 0.30

a = 0.33
# x = [[1, 2], [2, 3], [-1, 0], [0, -1], [0, 0], [0, 0], [0, 0], [0, 0]]
# W = [[1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3],
#      [1, 2, 4, 2, 7, 9, 2, 3]]
# r = [10, 10, 10, 10, 10, 10, 10, 10]
theta = 0
n = 30
n = n+1
m = 6
x = np.random.uniform(low=1, high=2, size=(n, 2, ))
W = np.random.uniform(low=2, high=2, size=(n, n, ))
r = np.array([50 for i in range(n)])
#Neigh = np.random.uniform(low=0, high=1, size=(n, n, ))
#Neigh = 10*np.random.randint(low=0,high=2,size=(n,n,))
"""Neigh = [[0,1,0,0,1,1,0,1,0,1],
         [1,0,1,0,0,1,1,0,1,0],
         [0,1,0,0,0,0,1,1,0,1],
         [0,0,0,0,0,1,0,0,1,1],
         [1,0,0,0,0,0,1,1,1,0],
         [1,1,0,1,0,0,0,0,0,0],
         [0,1,1,0,1,0,0,0,0,0],
         [1,0,1,0,1,0,0,0,0,0],
         [0,1,0,1,1,0,0,0,0,0],
         [1,0,1,1,0,0,0,0,0,0]]"""
#u = np.array(u)

'''Neigh = [[0  for i in range(30)] for j in range(30)]

for i in range(5,30):
    if i==29 or i==9 or i==14 or i==19 or i==24:
        continue
    topology[i][i+1]=0.5
    topology[i+1][i]=0.5

adjacent = [ [1,5,29,5,17],[9,22,3,10,2],[14,0,27,15],[19,20,7],[25,24,12]]

for i in range(5):
    for j in adjacent[i]:
        topology[i][j] = 1

print(topology)
'''

Neigh = [[0.0  for i in range(n)] for j in range(n)]

for i in range(1,5):
  Neigh[i][5*i+1] =1
  Neigh[5*i+2][5*i+1] =0.5
  Neigh[5*i+1][5*i+2] =0.5
  Neigh[5*i+3][5*i+2] =0.5
  Neigh[5*i+3][5*i+4] =0.5
  Neigh[5*(i+1)][5*i+4] =0.5
  Neigh[5*i+4][5*(i+1)] =0.5
  Neigh[i%5+1][5*(i+1)] =0.5
  
  Neigh[5*i+2][5*i+3] = Neigh[5*i+4][5*i+3] = 0.45
  Neigh[(i+2)%5 + 1][5*i+3] = 0.1

def getSig(v):
    vv = [ ]
    for i in v:
        vv.append((1 if i >= 0 else -1) * math.pow(abs(i), a))
    return np.array(vv)
def getH(i):
    return np.array([r[i] * math.cos(theta + 2 * i * math.pi / 5), r[i] * math.sin(theta + 2 * i * math.pi / 5)])
def sumLessEqM(i):
    global b, g, a, x, W, n, m, Neigh
    j = 0
    s = np.zeros((2, ))
    for j in range(n):
        if Neigh[i][j] > 0.0:
            s = s + W[i][j] * ((x[j] - getH(j)) - (x[i] - getH(i)))
    return b * getSig(s) + g * s
'''def func(upV, downV):
    upMod = upV % 5
    downMod = downV % 5
    upD = math.floor(upV / 5)
    downD = math.floor(downV / 5)
    if upD == downD and ((upMod == 1 and downMod == 0) or (upMod == 1 and downMod == 2) or (upMod == 2 and downMod == 1) or (upMod == 2 and downMod == 3) or (upMod == 4 and downMod == 3)):
        return 0.5
    if ((upD + 1) == downD and upMod == 4 and downMod == 0) or (upD == (downD + 1) and upMod == 0 and downMod == 4):
        return 0.5
    if upD == (downD + 1) and downMod == 1 and upMod == 0:
        return 0.5
    if upD == downD and ((upMod == 3 and downMod == 2) or (upMod == 3 and downMod == 4)):
        return 0.45
    if (upD + 2) == downD and upMod == 3 and downMod == 1:
        return 0.1
    return 0
'''
def sumGretM(i):
    global b, g, a, x, W, r, n, m,Neigh
    j = 0
    #s = func(i, j) * (x[j] - x[i])
    s = Neigh[i][j]
    for j in range(1, n):
        #s = s + func(i, j) * (x[j] - x[i])
        s = s + Neigh[i][j] *(x[j] - x[i])
    return b * getSig(s) + g * s

def getU(i):
    if i < m:
        return sumLessEqM(i)
    return sumGretM(i)

for i in range(100):
    Ux = [ ]
    Uy = [ ]
    for j in range(n):
    #for j in range(n):
        t = getU(j)
        x[j] = x[j] + t;
        Ux.append(x[j][0])
        Uy.append(x[j][1])
    Ux = np.array(Ux)
    Uy = np.array(Uy)
    plt.scatter(Ux, Uy)
    plt.show()

